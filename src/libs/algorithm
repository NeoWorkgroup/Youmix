#ifndef _YOUMIX_ALOGIRTHM_H_
#define _YOUMIX_ALOGIRTHM_H_

#include <stdint.h>
#include <stddef.h>

#include "utility"

namespace std {
template <typename InputIteraotr, typename Size, typename OutputIterator>
OutputIterator copy_n(InputIteraotr first, Size n, OutputIterator result) {
    while (n > 0) {
        *result = *first;
        ++result;
        ++first;
        --n;
    }
    return result;
}

template <typename OutputIterator, typename Size, typename T>
OutputIterator fill_n(OutputIterator first, Size n, const T &val) {
    while (n > 0) {
        *first = val;
        ++first;
        --n;
    }
    return first;
}

template <typename T> void swap(T &a, T &b) {
    T t(std::move(a));
    a = std::move(b);
    b = std::move(t);
}

template <typename ForwardIter>
void iter_swap(ForwardIter a, ForwardIter b) {
    swap(*a, *b);
}

template <typename BidirectionalIteraotr>
void reverse(BidirectionalIteraotr first, BidirectionalIteraotr last) {
    while ((first != last) && (first != --last)) {
        iter_swap(first, last);
        ++first;
    }
}

template <typename T, size_t N> void swap(T (&a)[N], T (&b)[N]) {
    swap_ranges(a, a + N, b);
}

template <typename ForwardIter1, typename ForwardIter2>
ForwardIter2 swap_ranges(ForwardIter1 first1, ForwardIter1 last1,
                         ForwardIter2 first2) {
    while (first1 != last1) {
        swap(*first1, *first2);
        ++first1;
        ++first2;
    }
}

template <typename T> const T &min(const T &a, const T &b) {
    return a < b ? a : b;
}

template <typename T> const T &max(const T &a, const T &b) {
    return a < b ? b : a;
}

template<typename InputIteraotr, typename Fn>
void for_each(InputIteraotr first, InputIteraotr end, Fn fn) {
    for (InputIteraotr iter = first; iter != end; ++iter)
        fn(*iter);
}

template<typename InputIteraotr, typename T>
InputIteraotr find(InputIteraotr first, InputIteraotr last, const T& val) {
    while (first != last) {
        if (*first == val)
            return first;
        ++first;
    }
    return last;
}

template<typename InputIteraotr, typename Pred>
InputIteraotr find_if(InputIteraotr first, InputIteraotr last, Pred fn) {
    while (first != last) {
        if (fn(*first))
            return first;
        ++first;
    }
    return last;
}

template<typename InputIteraotr, typename T>
size_t count(InputIteraotr first, InputIteraotr last, const T& val) {
    size_t ret = 0;
    while (first != last) {
        if (*first == val)
            ++ret;
        ++first;
    }
    return ret;
}

template<typename InputIteraotr, typename Pred>
size_t count_if(InputIteraotr first, InputIteraotr last, Pred fn) {
    size_t ret = 0;
    while (first != last) {
        if (fn(*first))
            ++ret;
        ++first;
    }
    return ret;
}

template<typename InputIteraotr1, typename InputIteraotr2>
bool equal(InputIteraotr1 first1, InputIteraotr1 last1, InputIteraotr2 first2) {
    while (first1 != last1) {
        if (!(*first1 == *first2))
            return false;
        ++first1;
        ++first2;
    }
    return true;
}

template<typename InputIteraotr1, typename InputIteraotr2, typename Pred>
bool equal(InputIteraotr1 first1, InputIteraotr1 last1, InputIteraotr2 first2, Pred fn) {
    while (first1 != last1) {
        if (!fn(*first1, *first2))
            return false;
        ++first1;
        ++first2;
    }
    return true;
}

template<typename InputIteraotr, typename OutputIterator, typename Operation>
OutputIterator transform(InputIteraotr first1, InputIteraotr last1, OutputIterator result, Operation op) {
    while (first1 != last1) {
        *result = op(*first1);
        ++result;
        ++first1;
    }
    return result;
}

template<typename ForwardIter>
ForwardIter unique(ForwardIter first, ForwardIter last) {
    if (first == last)
        return last;
    ForwardIter result = first;
    while (++first != last) {
        if (!(*result == *first))
            *++result = *first;
    }
    return ++result;
}

template<typename ForwardIter, typename BinaryPredicate>
ForwardIter unique(ForwardIter first, ForwardIter last, BinaryPredicate fn) {
    if (first == last)
        return last;
    ForwardIter result = first;
    while (++first != last) {
        if (!fn(*result, *first))
            *++result = *first;
    }
    return ++result;
}

template<typename ForwardIter, typename Pred>
ForwardIter partition(ForwardIter first, ForwardIter last, Pred fn) {
    if (first == last)
        return last;
    ForwardIter next = first;
    for (ForwardIter i = first + 1; i != last; ++i) {
        if (fn(*i))
            std::swap(*i, *++next);
    }
    std::swap(*next, *first);
    return ++next;
}

template<typename RandomAssessIterator>
void sort(RandomAssessIterator first, RandomAssessIterator last) {
    if (first == last || first == last - 1)
        return;
    for (RandomAssessIterator fst = first; fst != last && fst != last - 1; ) {
        auto tmp = *fst;
        RandomAssessIterator pivot =
            partition(fst, last, [=](decltype(*fst) x) { return x <= tmp; });
        sort(first, pivot);
        fst = pivot;
    }
}
}

#endif
