#ifndef _YOUMIX_FUNCTIONAL_HPP_
#define _YOUMIX_FUNCTIONAL_HPP_

#include "utility"
#include "memory"
#include "algorithm"

namespace std {
template<typename> class function;

template<typename R, typename... Args>
class function<R(Args...)> {
public:
    template<typename T>
    function(const T& fn) : pfunctor(new T(fn)), ref_cnt(new int(1)) {
        invoke = helper<T>::invoke;
        del = helper<T>::del;
    }

    function(R (*fn)(Args...)) : pfunctor(reinterpret_cast<void*>(fn)), ref_cnt(nullptr) {
        invoke = helper<R(Args...)>::invoke;
        del = helper<R(Args...)>::nop;
    }

    function(const function& rhs) 
        : pfunctor(rhs.pfunctor), ref_cnt(rhs.ref_cnt), invoke(rhs.invoke), del(rhs.del) {
            ++*ref_cnt;
    }

    ~function() { decr_ref(); }

    function& operator=(function rhs) {
        rhs.swap(*this);
        return *this;
    }

    void swap(function& rhs) {
        using std::swap;
        swap(pfunctor, rhs.pfunctor);
        swap(ref_cnt, rhs.ref_cnt);
        swap(invoke, rhs.invoke);
        swap(del, rhs.del);
    }

    R operator()(Args&&... args) const {
        return invoke(pfunctor, std::forward<Args>(args)...);
    }

private:
    void* pfunctor;
    int* ref_cnt;

    R (*invoke)(void*, Args&&...);
    void (*del)(void*);

    template<typename T>
    struct helper {
        static R invoke(void* p, Args&&... args) {
            return (*(T*)p)(std::forward<Args>(args)...);
        }
        static void del(void* p) { delete (T*)p; }
        static void nop(void*) { }
    };

    void decr_ref() {
        if (--*ref_cnt == 0) {
            delete ref_cnt;
            del(pfunctor);
        }
    }
};
}

#endif
